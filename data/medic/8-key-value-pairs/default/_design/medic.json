{
  "_id": "_design/medic",
  "_rev": "3-697fc5a09743575115ee35054a89dec4",
  "build_info": {
    "application": "medic",
    "author": "npm on runner",
    "base_version": "4.6.0",
    "build": "4.6.0-alpha.8437243664",
    "schema_version": 2,
    "time": "2024-03-26T14:03:07.700Z",
    "version": "master",
    "namespace": "medic"
  },
  "rewrites": [
    {
      "from": "/manifest.appcache",
      "to": "manifest.appcache"
    }
  ],
  "version": "4.6.0-alpha.8437243664",
  "validate_doc_update": "/*\n  SERVER DOCUMENT VALIDATION\n\n  This is for validating authority. It is against the medic ddoc because it can\n  only usefully be run against couchdb.\n\n  For validations around document structure (and for a validate_doc_update script\n  that runs on PouchDB) check ddocs/medic-client/validate_doc_update.js.\n*/\nfunction(newDoc, oldDoc, userCtx, secObj) {\n\n  var ADMIN_ONLY_TYPES = [ 'form', 'translations', 'token_login' ];\n  var ADMIN_ONLY_IDS = [\n    'resources',\n    'service-worker-meta',\n    'zscore-charts',\n    'settings',\n    'branding',\n    'partners',\n    'privacy-policies',\n    'extension-libs',\n  ];\n\n  var _err = function(msg) {\n    throw({ forbidden: msg });\n  };\n\n  var hasRole = function(userCtx, role) {\n    if (userCtx.roles) {\n      for (var i = 0; i < userCtx.roles.length; i++) {\n        if (userCtx.roles[i] === role) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  var isDbAdmin = function(userCtx, secObj) {\n    if (hasRole(userCtx, '_admin')) {\n      return true;\n    }\n\n    if (secObj.admins && secObj.admins.names &&\n        secObj.admins.names.indexOf(userCtx.name) !== -1) {\n      return true;\n    }\n\n    if (secObj.admins && secObj.admins.roles) {\n      for (var i = 0; i < userCtx.roles; i++) {\n        if (hasRole(secObj.admins, userCtx.roles[i])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  var isAdminOnlyDoc = function(doc) {\n    return (doc._id && doc._id.indexOf('_design/') === 0) ||\n           (doc._id && ADMIN_ONLY_IDS.indexOf(doc._id) !== -1) ||\n           (doc.type && ADMIN_ONLY_TYPES.indexOf(doc.type) !== -1);\n  };\n\n  var checkAuthority = function(newDoc, oldDoc, userCtx, secObj) {\n\n    // ensure logged in\n    if (!userCtx.name) {\n      _err('You must be logged in to edit documents');\n    }\n\n    // admins can do anything\n    if (isDbAdmin(userCtx, secObj)) {\n      return;\n    }\n\n    if (isAdminOnlyDoc(newDoc)) {\n      _err('You are not authorized to edit admin only docs');\n    }\n\n    if (userCtx.facility_id === newDoc._id) {\n      _err('You are not authorized to edit your own place');\n    }\n  };\n\n  if (newDoc.purged) {\n    // Remove this once we move purging to the server side, for now it is to\n    // prevent *client-side* purging from leaking into the server side\n    return _err('Purged documents should not be written to CouchDB!');\n  }\n\n  checkAuthority(newDoc, oldDoc, userCtx, secObj);\n  log('medic validate_doc_update passed for User \"' + userCtx.name + '\" changing document \"' +  newDoc._id + '\"');\n}",
  "views": {
    "doc_summaries_by_id": {
      "map": "// WARNING: This is a copy of the GetSummaries service\n// with some minor modifications and needs to be kept in sync until\n// this workaround is no longer needed.\n// https://github.com/medic/medic/issues/4666\n\nfunction(doc) {\n  var getLineage = function(contact) {\n    var parts = [];\n    while (contact) {\n      if (contact._id) {\n        parts.push(contact._id);\n      }\n      contact = contact.parent;\n    }\n    return parts;\n  };\n\n  var isMissingSubjectError = function(error) {\n    if (error.code !== 'sys.missing_fields' || !error.fields) {\n      return false;\n    }\n\n    if (error.fields.indexOf('patient_id') !== -1 ||\n      error.fields.indexOf('patient_uuid') !== -1 ||\n      error.fields.indexOf('patient_name') !== -1 ||\n      error.fields.indexOf('place_id') !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var getSubject = function(doc) {\n    var subject = {};\n    var reference = doc.patient_id ||\n                    (doc.fields && doc.fields.patient_id) ||\n                    (doc.fields && doc.fields.patient_uuid) ||\n                    doc.place_id ||\n                    (doc.fields && doc.fields.place_id);\n\n    var patientName = doc.fields && doc.fields.patient_name;\n    if (patientName) {\n      subject.name = patientName;\n    }\n\n    if (reference) {\n      subject.value = reference;\n      subject.type = 'reference';\n    } else if (patientName) {\n      subject.value = patientName;\n      subject.type = 'name';\n    } else if (doc.errors) {\n      doc.errors.forEach(function(error) {\n        if (isMissingSubjectError(error)) {\n          subject.type = 'unknown';\n        }\n      });\n    }\n\n    return subject;\n  };\n\n  if (doc.type === 'data_record' && doc.form) { // report\n    emit(doc._id, {\n      _rev: doc._rev,\n      from: doc.from || doc.sent_by,\n      phone: doc.contact && doc.contact.phone,\n      form: doc.form,\n      read: doc.read,\n      valid: !doc.errors || !doc.errors.length,\n      verified: doc.verified,\n      reported_date: doc.reported_date,\n      contact: doc.contact && doc.contact._id,\n      lineage: getLineage(doc.contact && doc.contact.parent),\n      subject: getSubject(doc),\n      case_id: doc.case_id || (doc.fields && doc.fields.case_id)\n    });\n  } else if (doc.type === 'contact' ||\n      doc.type === 'clinic' ||\n      doc.type === 'district_hospital' ||\n      doc.type === 'health_center' ||\n      doc.type === 'person') { // contact\n    emit(doc._id, {\n      _rev: doc._rev,\n      name: doc.name || doc.phone,\n      phone: doc.phone,\n      type: doc.type,\n      contact_type: doc.contact_type,\n      contact: doc.contact && doc.contact._id,\n      lineage: getLineage(doc.parent),\n      date_of_death: doc.date_of_death,\n      muted: doc.muted\n    });\n  }\n}"
    },
    "docs_by_replication_key": {
      "map": "function (doc) {\n  if (doc._id === 'resources' ||\n      doc._id === 'branding' ||\n      doc._id === 'partners' ||\n      doc._id === 'service-worker-meta' ||\n      doc._id === 'zscore-charts' ||\n      doc._id === 'settings' ||\n      doc._id === 'privacy-policies' ||\n      doc.type === 'form' ||\n      doc.type === 'translations') {\n    return emit('_all', {});\n  }\n  var getSubject = function() {\n    if (doc.form) {\n      // report\n      if (doc.contact && doc.errors && doc.errors.length) {\n        for (var i = 0; i < doc.errors.length; i++) {\n          // invalid or no patient found, fall back to using contact. #3437\n          if (doc.errors[i].code === 'registration_not_found' ||\n              doc.errors[i].code === 'invalid_patient_id') {\n            return doc.contact._id;\n          }\n        }\n      }\n      return (doc.patient_id || (doc.fields && doc.fields.patient_id)) ||\n             (doc.place_id || (doc.fields && doc.fields.place_id)) ||\n             (doc.fields && doc.fields.patient_uuid) ||\n             (doc.contact && doc.contact._id);\n    }\n    if (doc.sms_message) {\n      // incoming message\n      return doc.contact && doc.contact._id;\n    }\n    if (doc.kujua_message) {\n      // outgoing message\n      return doc.tasks &&\n             doc.tasks[0] &&\n             doc.tasks[0].messages &&\n             doc.tasks[0].messages[0] &&\n             doc.tasks[0].messages[0].contact &&\n             doc.tasks[0].messages[0].contact._id;\n    }\n  };\n  var value = { type: doc.type };\n  switch (doc.type) {\n    case 'data_record':\n      value.subject = getSubject() || '_unassigned';\n      if (doc.form && doc.contact) {\n        value.submitter = doc.contact._id;\n      }\n      if (doc.fields && doc.fields.private) {\n        value.private = true;\n      }\n      emit(value.subject, value);\n      if (doc.fields &&\n          doc.fields.needs_signoff &&\n          doc.contact\n      ) {\n        value.needs_signoff = true;\n        var contact = doc.contact;\n        while (contact) {\n          if (contact._id && contact._id !== value.subject) {\n            emit(contact._id, value);\n          }\n          contact = contact.parent;\n        }\n      }\n      return;\n    case 'task':\n      return emit(doc.user, value);\n    case 'target':\n      return emit(doc.owner, value);\n    case 'contact':\n    case 'clinic':\n    case 'district_hospital':\n    case 'health_center':\n    case 'person':\n      return emit(doc._id, value);\n  }\n}"
    },
    "contacts_by_depth": {
      "map": "function(doc) {\n  if (['contact', 'person', 'clinic', 'health_center', 'district_hospital'].indexOf(doc.type) !== -1) {\n    var value = doc.patient_id || doc.place_id;\n    var parent = doc;\n    var depth = 0;\n    while (parent) {\n      if (parent._id) {\n        emit([parent._id], value);\n        emit([parent._id, depth], value);\n      }\n      depth++;\n      parent = parent.parent;\n    }\n  }\n}"
    },
    "docs_by_shortcode": {
      "map": "function(doc) {\n  if (doc.place_id) {\n    emit(doc.place_id);\n  }\n  if (doc.patient_id) {\n    emit(doc.patient_id);\n  }\n  if (doc.case_id) {\n    emit(doc.case_id);\n  }\n}"
    },
    "messages_by_state": {
      "map": "function (doc) {\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      var due = task.due || task.timestamp || // for scheduled_message\n                doc.reported_date; // for immediate reply to form submission\n      if (typeof due === 'string') {\n        due = Date.parse(due).valueOf();\n      }\n      if (task.messages) {\n        task.messages.forEach(function(msg) {\n          if (msg.uuid && msg.to && msg.message) {\n            var value = {\n              content: msg.message,\n              to: msg.to,\n              id: msg.uuid,\n            };\n            emit([ task.state, due ], value);\n            if (task.state === 'pending' || task.state === 'forwarded-to-gateway') {\n              // emit a single state so we can sort by due date in the view\n              emit([ 'pending-or-forwarded', due ], value);\n            }\n          }\n        });\n      } else {\n        emit([ task.state, due ], {});\n      }\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n}"
    },
    "reports_by_form_and_parent": {
      "map": "function(doc) {\n  if (doc.type === 'data_record' &&\n      doc.form &&\n      doc.contact &&\n      doc.contact.parent) {\n    var value = typeof doc.reported_date === 'number' ? doc.reported_date : 0;\n    emit([doc.form, doc.contact.parent._id], value);\n  }\n}",
      "reduce": "_stats"
    },
    "reports_by_form_year_week_parent_reported_date": {
      "map": "function (doc) {\n  if (doc.type === 'data_record' &&\n      doc.contact &&\n      doc.contact.parent &&\n      doc.fields &&\n      doc.fields.year &&\n      (doc.fields.week || doc.fields.week_number) &&\n      doc.form &&\n      doc.reported_date) {\n    emit([\n      doc.form,\n      doc.fields.year,\n      doc.fields.week || doc.fields.week_number,\n      doc.contact.parent._id,\n      doc.reported_date\n    ]);\n  }\n}"
    },
    "reports_by_form_year_month_parent_reported_date": {
      "map": "function (doc) {\n  if (doc.type === 'data_record' &&\n      doc.contact &&\n      doc.contact.parent &&\n      doc.fields &&\n      doc.fields.year &&\n      (doc.fields.month || doc.fields.month_num) &&\n      doc.form &&\n      doc.reported_date) {\n    emit([\n      doc.form,\n      doc.fields.year,\n      doc.fields.month || doc.fields.month_num,\n      doc.contact.parent._id,\n      doc.reported_date\n    ]);\n  }\n}"
    },
    "tasks_in_terminal_state": {
      "map": "function(doc) {\n  if (doc.type === 'task') {\n    var isTerminalState = ['Cancelled', 'Completed', 'Failed'].indexOf(doc.state) >= 0;\n    if (isTerminalState && doc.emission) {\n      emit(doc.emission.endDate);\n    }\n  }\n}"
    }
  },
  "deploy_info": {
    "timestamp": 1711523164612
  }
}